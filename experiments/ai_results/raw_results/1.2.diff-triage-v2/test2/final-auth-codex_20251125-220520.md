# Final Verification

## CVE-2025-49706 – Authentication Bypass (ToolPane.aspx signout spoof)
**Diff evidence:** `diff_reports/v1-to-v2.server-side.patch` hunk at SPRequestModule.PostAuthenticateRequestHandler (`Microsoft.-52195226-3676d482/Microsoft/SharePoint/ApplicationRuntime/SPRequestModule.cs` and same in `Microsoft.-67953109-566b57ea`).
```
- if (IsShareByLinkPage(...) || ... || context.Request.Path.StartsWith(signoutPathRoot) ... || (uri != null && (SPUtility.StsCompareStrings(uri.AbsolutePath, signoutPathRoot) ...)))
+ bool flag8 = uri != null && (SPUtility.StsCompareStrings(uri.AbsolutePath, signoutPathRoot) ...);
+ if (IsShareByLinkPage(...) || ... || context.Request.Path.StartsWith(signoutPathRoot) ... || flag8)
  {
    flag6 = false;
    flag7 = true;
+   bool flag9 = !SPFarm.CheckFlag((ServerDebugFlags)53506);
+   bool flag10 = context.Request.Path.EndsWith("ToolPane.aspx", StringComparison.OrdinalIgnoreCase);
+   if (flag9 && flag8 && flag10)
+   {
+     flag6 = true;
+     flag7 = false;
+     ULS.SendTraceTag(... "Risky bypass limited (Access Denied) - signout with ToolPane.aspx detected..."
+   }
  }
```

**V1 behavior (vulnerable):** In v1 (`snapshots_decompiled/v1/.../SPRequestModule.cs:2700+`), the block sets `flag6=false; flag7=true;` whenever the request path or referrer matches signout/start/sharebylink/anonymous lists. For unauthenticated requests, the later branch only sends 401 when `flag6` is true. With `flag6=false`, unauthenticated ToolPane.aspx requests can skip the 401 response, effectively allowing the request to proceed without auth enforcement. Untrusted input: attacker-controlled HTTP request path/referrer. Missing check: no special-case for privileged ToolPane.aspx when referrer is signout. Outcome: anonymous user can reach ToolPane.aspx (admin/edit surface) by forging referrer to signout URLs, bypassing authentication.

**Bypass routes validated:**
- Route: unauthenticated GET to `/_layouts/15/ToolPane.aspx` (or variant) with forged Referer to any signout path (root/previous/current) -> `flag7=true`, `flag6=false` -> no 401. Feasibility: High (referrer spoofing is client-controlled; ToolPane.aspx is under layouts). Preconditions: auth mode requiring cookie check; no kill-switch 53506 engaged.
- Other bypass-listed endpoints (share-by-link, anonymous vti/dynamic) remain but were not modified; no evidence they reach privileged surfaces like ToolPane, so not validated as bypass to sensitive UI. Only the ToolPane+signout case is confirmed here.

**V2 mitigation:** Added `flag8` referrer check + ToolPane.aspx guard to force `flag6=true` and `flag7=false`, restoring 401 for this path, with a kill-switch override. This directly blocks the identified bypass (signout referrer + ToolPane). Bypass completeness: closes the ToolPane+signout path; other bypass-listed endpoints remain unchanged (potential but unvalidated). Feasibility of bypassing fix: would require other endpoints still allowed when `flag6=false`; ToolPane is now gated. Confidence: High (code shows explicit gating and logging).

**Status:** Confirmed. Distinct bypass routes validated: 1 (ToolPane with signout referrer). Other possible routes not evidenced in code are unvalidated.

## CVE-2025-49706 – ProofTokenSignInPage redirect fragment
**Diff evidence:** `diff_reports/v1-to-v2.server-side.patch` at `Microsoft.-1bae7604-1834fb48/Microsoft/SharePoint/IdentityModel/ProofTokenSignInPage.cs` ShouldRedirectWithProofToken.
```
- if (null != RedirectUri) { result = IsAllowedRedirectUrl(RedirectUri); }
+ if (null != RedirectUri)
+ {
+   result = IsAllowedRedirectUrl(RedirectUri);
+   if ((!SPFarm.Local.ServerDebugFlags.Contains(53020)) && !string.IsNullOrEmpty(RedirectUri.Fragment))
+   {
+     ULS.SendTraceTag(... "Hash parameter is not allowed.");
+     result = false;
+   }
+ }
```

**V1 behavior (vulnerable):** V1 accepts any absolute `redirect_uri` passing site-subscription checks, even with `#fragment`. Input: attacker-controlled query parameter `redirect_uri`. Flow: Accepts URI, issues proof/identity tokens (lines ~310+), then redirects. Missing check: no rejection of fragment component, allowing token redirect to URLs with fragments potentially pointing to attacker-controlled SPA anchor. Outcome: token/redirect can be steered to attacker-controlled fragment target, enabling spoofing/credential forwarding without additional auth. Preconditions: ability to hit ProofTokenSignInPage unauthenticated (AllowAnonymousAccess=true).

**Bypass routes validated:**
- Redirect URI containing fragment (`#...`), including encoded `%23`, accepted and used for post-token redirect. Feasibility: High (parameter controlled by requester). Alternative host/path without fragments remains accepted—potential residual risk but not shown fixed. Only fragment-based bypass confirmed here.

**V2 mitigation:** Explicit fragment check sets result=false when fragment present (unless kill-switch 53020). Blocks fragment-based redirect abuse. Completeness: Addresses fragment channel; does not alter host/path validation (residual risk if host/path validation is weak). Confidence: Medium-High (code clearly blocks fragments; broader redirect abuse not addressed).

**Status:** Confirmed (fragment-based redirect bypass). Distinct bypass routes validated: 1 (fragment). Other routes (host/path abuse without fragment) not validated.

## Deserialization hardening – Microsoft.Ssdqs.Infra (BinaryFormatter binder)
**Diff evidence:** `diff_reports/v1-to-v2.server-side.patch` around NoneVersionSpecificSerializationBinder change and new TypeProcessor (`Microsoft.-b23f4965-73cc7a11`).
```
- value = Type.GetType(typeName + ", " + assemblyName);
+ value = TypeProcessor.LoadType(assemblyName, typeName);
+ if (value == null) throw new BlockedTypeException(... InDeny);
+ if (TypeProcessor.IsTypeExplicitlyDenied(value)) throw ...
+ if (!TypeProcessor.IsTypeExplicitlyAllowed(value)) throw ...
```
New file `TypeProcessor.cs` with explicit allow/deny lists and disallowed generics.

**V1 behavior (vulnerable hypothesis):** Binder resolves arbitrary types via `Type.GetType` with adjusted assembly names; no allow/deny checks. If this binder is used with BinaryFormatter on untrusted data, attacker can supply type names leading to dangerous gadget types. Untrusted input: serialized payload type metadata. Missing check: allowlist/denylist. Outcome: potential deserialization gadget execution (RCE/priv-esc) if reachable remotely. Preconditions: need a code path that uses this binder on attacker-controlled data (not shown in provided snippets).

**V2 mitigation:** Routes type resolution through TypeProcessor with explicit allowed primitives/collections, deny list of dangerous framework/SharePoint types, and explicit exceptions when not allowed. This prevents arbitrary type activation through the binder. Confidence: Medium (clear hardening, but exploitability path not demonstrated in provided code). Status: Unproven/speculative RCE candidate (possible CVE-2025-49701).

## Deserialization hardening – Search CookieAuthData
**Diff evidence:** `diff_reports/v1-to-v2.server-side.patch` new class `Microsoft.Office.Server.Search.Administration.CookieAuthData` plus KnownType attribute additions.
Key snippet:
```
BinaryFormatter bf = new BinaryFormatter { Binder = new SafeSerialization.ExplicitReferenceSerializationBinder<Cookie>("DeserializeCookieAuthData") };
... bf.Deserialize(stream) is Cookie cookie -> add
```

**V1 behavior (vulnerable hypothesis):** Cookie-based auth data previously serialized/deserialized without a constrained binder (class absent). Introducing explicit binder suggests prior deserialization of base64 cookies could instantiate arbitrary types. Untrusted input: cookie values stored as base64 BinaryFormatter payloads. Missing check: type restriction. Outcome: potential deserialization gadget execution if attacker can supply crafted cookie auth data (e.g., via admin UI? exact surface unclear).

**V2 mitigation:** Uses SafeSerialization binder restricting to `System.Net.Cookie`, logs errors, and skips bad entries. Confidence: Medium-Low (hardening evident; exploitable surface not shown). Status: Unproven/speculative RCE/priv-esc candidate (possible CVE-2025-49701 or ancillary hardening).

## Coverage / Unmapped Security-Relevant Changes
- TypeProcessor/NoneVersionSpecificSerializationBinder: security hardening; mapped as RCE candidate; exploit path not confirmed.
- CookieAuthData with safe binder: security hardening; mapped as RCE/priv-esc candidate; exploit path not confirmed.
- Rankdetail/bypasscheckadminaccess stripping in SearchServiceApplicationProxy: confidentiality hardening; not tied to CVE; no bypass route beyond rank logs.
- Other auth-exempt endpoints in SPRequestModule remain unchanged; potential but unvalidated bypass surfaces.

## Confidence and Status
- ToolPane.aspx signout spoof auth bypass: **Confirmed**, confidence High; validated 1 bypass route (ToolPane + signout referrer). Other routes unvalidated.
- ProofTokenSignInPage fragment redirect: **Confirmed**, confidence Medium-High; validated 1 bypass route (fragment). Other redirect abuses unvalidated.
- TypeProcessor/BinaryFormatter hardening: **Unproven/speculative**, confidence Medium; candidate for CVE-2025-49701.
- CookieAuthData binder: **Unproven/speculative**, confidence Medium-Low; candidate/ancillary hardening.

## Bypass Validation Summary
- CVE-2025-49706 auth bypass: Confirmed 1 distinct bypass route (ToolPane + signout referrer). Other bypass-listed endpoints not validated.
- CVE-2025-49706 redirect: Confirmed 1 distinct bypass route (redirect_uri with fragment). Other redirect abuses not validated.
- CVE-2025-49704: No direct evidence in reviewed snippets; dangerous types not enumerated.
- CVE-2025-49701: Candidates identified (BinaryFormatter binder hardening; CookieAuthData binder), speculative.
- Overall coverage: I may have missed alternative bypass routes; only the above were validated with code evidence.
